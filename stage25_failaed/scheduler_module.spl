print "inside scheduler";
alias pid R0;
pid=[SYSTEM_STATUS_TABLE+1];
multipush(BP);
alias process_table_entry R2;
process_table_entry=PROCESS_TABLE+pid*16;
print [process_entry+9];
if([process_entry+9]==13) then
    alias i R3;
    i=0;
    while(i<16) do
        print "process:";
        print i;
        print "state:";
        print "(";
        print [PROCESS_TABLE+i*16+4];
        print ",";
        print [PROCESS_TABLE+i*16+5];
        print ")";
        i=i+1;
    endwhile;
endif;
[process_table_entry+12]=SP%512;
[process_table_entry+14]=PTBR;
[process_table_entry+15]=PTLR;

alias newPID R3;
newPID=pid+1;

alias new_process_entry R4;
while(newPID<16) do
    new_process_entry = PROCESS_TABLE+newPID*16;
    if([new_process_entry+4]==READY || [new_process_entry+4]==CREATED) then
        break;
    endif;
    newPID=newPID+1;
endwhile;

if(newPID==16) then
    newPID=0;
endif;
new_process_entry=PROCESS_TABLE+newPID*16;

[SYSTEM_STATUS_TABLE+1]=newPID;
PTBR=[new_process_entry+14];
PTLR=[new_process_entry+15];

if([new_process_entry+4]==CREATED) then
    SP=[new_process_entry+13];
    BP=[[new_process_entry+11]*512];
    [new_process_entry+4]=RUNNING;
    [new_process_entry+9]=0;
    ireturn;
endif;

SP=[PROCESS_TABLE+newPID*16+11]*512+[PROCESS_TABLE+newPID*16+12];
[new_process_entry+4]=RUNNING;
[new_process_entry+9]=0;

multipop(BP);
return;
