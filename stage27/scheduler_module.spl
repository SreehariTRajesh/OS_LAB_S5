//module 5
alias currentPID R0;
currentPID = [SYSTEM_STATUS_TABLE + 1];

//The ExpL application does not push the Base Pointer register (BP)
multipush(BP);

alias processTableEntry R1;
processTableEntry = PROCESS_TABLE + 16*currentPID;

[processTableEntry + 12] = SP % PAGE_SIZE;		//kptr
[processTableEntry + 14] = PTBR;
[processTableEntry + 15] = PTLR;


alias scheduleProc R1;
scheduleProc = IDLE_PROCESS;

//if paging status is not 0 [paging is ongoing]
if([SYSTEM_STATUS_TABLE + 5] != 0) then
	if([PROCESS_TABLE + 16*SWAPPER_DAEMON + 4] != WAIT_DISK) then		//not blocked by disk operation
		scheduleProc = SWAPPER_DAEMON;
	endif;

else
	alias procId R2;
	procId = (currentPID+1) % MAX_PROC_NUM;
	alias procCount R3;
	procCount = 0;
	while (procCount < MAX_PROC_NUM) do
		R4 = [PROCESS_TABLE + 16*procId + 4];
		if (
			procId != IDLE_PROCESS && 
			procId != SWAPPER_DAEMON && 
			[PROCESS_TABLE + 16*procId + 6] == 0 &&		//not swapped
			(R4 == CREATED || R4 == READY)
		) then
			scheduleProc = procId;
			break;
		endif;

		procId = (procId + 1) % MAX_PROC_NUM;
		procCount = procCount + 1;
	endwhile;
endif;

[SYSTEM_STATUS_TABLE + 1] = scheduleProc;

alias newProcessTable R2;
newProcessTable = PROCESS_TABLE + 16*scheduleProc;

PTBR = [newProcessTable + 14];
PTLR = [newProcessTable + 15];

//if newly created then no user context to restore
if([newProcessTable + 4] == CREATED) then
	//BP is saved to the beginning of the kernel stack by Fork call at process creation
	BP = [[newProcessTable + 11]*PAGE_SIZE];
	[newProcessTable + 4] = RUNNING;
	[newProcessTable + 9] = 0;				//mode flag
	SP = [newProcessTable + 13];
	ireturn;
endif;

[newProcessTable + 4] = RUNNING;

SP =  [newProcessTable+11] * PAGE_SIZE + [newProcessTable+12];

multipop(BP);

return;